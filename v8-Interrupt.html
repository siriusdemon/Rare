<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interrupt - Rare: Rust A Riscv Emulator</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Rust A RISC-V Emulator</a></li><li class="chapter-item expanded "><a href="v1-CPU-Adder.html"><strong aria-hidden="true">1.</strong> Adder</a></li><li class="chapter-item expanded "><a href="v2-Memory-and-Bus.html"><strong aria-hidden="true">2.</strong> Memory and Bus</a></li><li class="chapter-item expanded "><a href="v3-CSR.html"><strong aria-hidden="true">3.</strong> Control Status Register</a></li><li class="chapter-item expanded "><a href="v4-Privilege-Mode.html"><strong aria-hidden="true">4.</strong> Privilege Mode</a></li><li class="chapter-item expanded "><a href="v5-Exception.html"><strong aria-hidden="true">5.</strong> Exception</a></li><li class="chapter-item expanded "><a href="v6-Plic-Clint.html"><strong aria-hidden="true">6.</strong> PLIC &amp; CLINT</a></li><li class="chapter-item expanded "><a href="v7-Uart.html"><strong aria-hidden="true">7.</strong> UART</a></li><li class="chapter-item expanded "><a href="v8-Interrupt.html" class="active"><strong aria-hidden="true">8.</strong> Interrupt</a></li><li class="chapter-item expanded "><a href="v9-Virtio.html"><strong aria-hidden="true">9.</strong> Virtio</a></li><li class="chapter-item expanded "><a href="v10-Page-Table.html"><strong aria-hidden="true">10.</strong> Page Table</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rare: Rust A Riscv Emulator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interrupt"><a class="header" href="#interrupt">Interrupt</a></h1>
<p>Interrupt is an external event generated by peripheral devices. CPU will handle an interrupt after it have fully executed an instruction, which is quite difference from handling exceptions. Consequently, when CPU encounters an exception, the PC points to the instruction that causes the exception. When CPU encounters an interrupt, the PC points to the instruction that it haven't executed.</p>
<p>中断是一个由外围设备产生的事件。CPU 会在它执行完一条完整指令之后处理中断，这一点不同于对异常的处理。当 CPU 遇到异常时，PC 会指向那个造成这个异常的指令。当 CPU 遇到中断时，PC 会指向一个指令它原准备要执行的指令。</p>
<h3 id="1-interrupt-type"><a class="header" href="#1-interrupt-type">1. Interrupt type</a></h3>
<p>RISC-V has defined six interrupt types. </p>
<p>RISC-V 现有 6 种异常状态。</p>
<p><img src="./images/interrupt.png" alt="interrupt" /></p>
<p class="comment">mcause/scause and interrupt code. From RISC-V Privileged<p>
<p>The software interrupt and timer interrupt are generated by CLINT, while the external interrupt is generated by PLIC as we have mentioned in last chapter.</p>
<p>When an interrupt is generated, corresponding field in mip/sip is set to 1. Fields in mie/sie controls whether the corresponding interrupt is enabled or disabled.</p>
<p>我们在上一节中已提过，软件中断和时钟中断是由 CLINT 产生的，外部中断是由 PLIC 产生的。</p>
<p>当发生中断时，mip/sip 上相应的位会置 1，mie/sie 的字段启动或者屏蔽特定的中断。</p>
<p><img src="./images/mip-mie.png" alt="mip-mie" /></p>
<p>When a hart is executing in privilege mode x, interrupts are globally enabled when xIE=1 and globally disabled when xIE=0. Interrupts for lower-privilege modes, w &lt; x, are always globally disabled regardless of the setting of any global wIE bit for the lower-privilege mode. Interrupts for higher-privilege modes, y &gt; x, are always globally enabled regardless of the setting of the global yIE bit for the higher-privilege mode. Higher-privilege-level code can use separate per-interrupt enable bits to disable selected higher-privilege-mode interrupts before ceding control to a lower-privilege mode.</p>
<p>An interrupt i will trap to M-mode (causing the privilege mode to change to M-mode) if all of the following are true: (a) either the current privilege mode is M and the MIE bit in the mstatus register is set, or the current privilege mode has less privilege than M-mode; (b) bit i is set in both mip and mie; and (c) if register mideleg exists, bit i is not set in mideleg.</p>
<p>Trap in S-mode is quite similarly.</p>
<p>Multiple simultaneous interrupts destined for M-mode are handled in the following decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI.</p>
<p>Read the Section 3.1.6.1, 3.1.9 and 4.1.3 of RISC-V Privileged for more information.</p>
<p>当一个 hart 运行在特权模式 x 时，若 xIE=1 则中断全局可用，否则全局中断被屏蔽。对于特权等级小于 x 的，其全局中断总是被屏蔽的。对于特权等级高于 x 的，其全局中断总是开启的。较高级特权模式在进入较低级的模式之前，可以先禁用掉某些中断，这样，即便是在低等级的模式下，也不会响应那些中断。</p>
<p>一个中断 i 要陷入到 M 模式，需要满足以下条件：（a）当前的模式是 M 且 MIE=1，或当前模式比 M 模式低级；（b）mip 和 mie 中相应的位 i 都为 1；（c）如果存在 mideleg 寄存器，mideleg 中的 i 位为 0.</p>
<p>陷入到 S 模式与此相似。</p>
<p>若有多个中断同时到达，M 模式将会按以下优化级顺序处理：MEI，MSI，MTI，SEI，SSI，STI。</p>
<p>RISC-V 特权架构文档的 3.1.6.1, 3.1.9 和 4.1.3 节有更多详细的内容。</p>
<h3 id="2-interrupt-handle"><a class="header" href="#2-interrupt-handle">2. Interrupt handle</a></h3>
<p>The procedure of handling interrupt is similar to that of handling exception. For convenience, I summarize the process as follows:</p>
<ol>
<li>update hart's privilege mode (M or S according to current mode and exception setting).</li>
<li>save current pc in epc (sepc in S-mode, mepc in M-mode)</li>
<li>set pc properly according to the MODE field of trap vector (stvec in S-mode, mtvec in M-mode)</li>
<li>set cause register with exception code (scause in S-mode, mcause in M-mode)</li>
<li>set xPIE to xIE (SPIE in S-mode, MPIE in M-mode)</li>
<li>clear up xIE (SIE in S-mode, MIE in M-mode)</li>
<li>set xPP to previous mode.</li>
</ol>
<p>There are two different points compared with exception. First, we omit the set up of trap value. Second, we have to set up the pc according to the MODE field of trap vector.</p>
<p>中断的处理过程与异常是非常相似的。为方便起见，我们将该过程总结如下：</p>
<p>1、更新 hart 的特权模式
2、保存 pc 至 epc
3、根据 trap vector 的 MODE 字段的值来设置 pc。
4、保存中断的异常代码到 cause 寄存器中
5、令 xPIE = xIE
6、令 xIE = 0
7、将进入中断前的模式保存到 xPP 中</p>
<p>以上有两个地方是与异常不同的。一是我们不需要处理 trap value。二是我们要根据 trap vector 的 MODE 字段的值来设置 PC。</p>
<p><img src="./images/trap-vector.png" alt="trap-vector" /></p>
<p class=comment>trap vector</p>
<p><img src="./images/trap-vector-base.png" alt="trap-vector-base" /></p>
<p class=comment>encoding of trap vector MODE field.</p>
<p>Read the Section 3.1.7 in RISC-V Privileged for more details.</p>
<p>RISC-V 特权架构文档的 3.1.7 节有更多详细内容。</p>
<h3 id="3-implementation"><a class="header" href="#3-implementation">3. Implementation</a></h3>
<p>The interrupt enum is defined in <code>interrupt.rs</code>. Since we don't have to deal with trap value, the interrupt structure only owns a <code>code</code> method.</p>
<p>中断的数据结构定义在 <code>interrupt.rs</code> 中。因为我们不再需要处理 trap value，所以只需要一个 code 方法。</p>
<p class="filename">interrupt.rs</p>
<pre><code class="language-rs">pub const MASK_INTERRUPT_BIT: u64 = 1 &lt;&lt; 63;

#[derive(Debug, Copy, Clone)]
pub enum Interrupt {
    SupervisorSoftwareInterrupt,
    MachineSoftwareInterrupt,
    SupervisorTimerInterrupt,
    MachineTimerInterrupt,
    SupervisorExternalInterrupt,
    MachineExternalInterrupt,
}



impl Interrupt {
    pub fn code(self) -&gt; u64 {
        use Interrupt::*;
        match self {
            SupervisorSoftwareInterrupt =&gt; 1 | MASK_INTERRUPT_BIT,
            MachineSoftwareInterrupt =&gt; 3 | MASK_INTERRUPT_BIT,
            SupervisorTimerInterrupt =&gt; 5 | MASK_INTERRUPT_BIT,
            MachineTimerInterrupt =&gt; 7 | MASK_INTERRUPT_BIT,
            SupervisorExternalInterrupt =&gt; 9 | MASK_INTERRUPT_BIT,
            MachineExternalInterrupt =&gt; 11 | MASK_INTERRUPT_BIT,
        }
    }
}
</code></pre>
<p>There are two places we need to modify to enable interrupt handling. One is in <code>cpu.rs</code>, another is in <code>main.rs</code>.</p>
<p>Firstly, we need to introduce interrupt handling for our cpu.</p>
<p>有两个地方需要改动：一个在 cpu.rs，还有一个在 main.rs。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">impl Cpu {
    pub fn handle_interrupt(&amp;mut self, interrupt: Interrupt) {
        // similar to handle exception
        let pc = self.pc; 
        let mode = self.mode;
        let cause = interrupt.code();
        // although cause contains a interrupt bit. Shift the cause make it out.
        let trap_in_s_mode = mode &lt;= Supervisor &amp;&amp; self.csr.is_midelegated(cause);
        let (STATUS, TVEC, CAUSE, TVAL, EPC, MASK_PIE, pie_i, MASK_IE, ie_i, MASK_PP, pp_i) 
            = if trap_in_s_mode {
                self.mode = Supervisor;
                (SSTATUS, STVEC, SCAUSE, STVAL, SEPC, MASK_SPIE, 5, MASK_SIE, 1, MASK_SPP, 8)
            } else {
                self.mode = Machine;
                (MSTATUS, MTVEC, MCAUSE, MTVAL, MEPC, MASK_MPIE, 7, MASK_MIE, 3, MASK_MPP, 11)
            };
        // 3.1.7 &amp; 4.1.2
        // When MODE=Direct, all traps into machine mode cause the pc to be set to the address in the BASE field. 
        // When MODE=Vectored, all synchronous exceptions into machine mode cause the pc to be set to the address 
        // in the BASE field, whereas interrupts cause the pc to be set to the address in the BASE field plus four 
        // times the interrupt cause number. 
        let tvec = self.csr.load(TVEC);
        let tvec_mode = tvec &amp; 0b11;
        let tvec_base = tvec &amp; !0b11;
        match tvec_mode { // DIrect
            0 =&gt; self.pc = tvec_base,
            1 =&gt; self.pc = tvec_base + cause &lt;&lt; 2,
            _ =&gt; unreachable!(),
        };
        // 3.1.14 &amp; 4.1.7
        // When a trap is taken into S-mode (or M-mode), sepc (or mepc) is written with the virtual address 
        // of the instruction that was interrupted or that encountered the exception.
        self.csr.store(EPC, pc);
        // 3.1.15 &amp; 4.1.8
        // When a trap is taken into S-mode (or M-mode), scause (or mcause) is written with a code indicating 
        // the event that caused the trap.
        self.csr.store(CAUSE, cause);
        // 3.1.16 &amp; 4.1.9
        // When a trap is taken into M-mode, mtval is either set to zero or written with exception-specific 
        // information to assist software in handling the trap. 
        self.csr.store(TVAL, 0);
        // 3.1.6 covers both sstatus and mstatus.
        let mut status = self.csr.load(STATUS);
        // get SIE or MIE
        let ie = (status &amp; MASK_IE) &gt;&gt; ie_i;
        // set SPIE = SIE / MPIE = MIE
        status = (status &amp; !MASK_PIE) | (ie &lt;&lt; pie_i);
        // set SIE = 0 / MIE = 0
        status &amp;= !MASK_IE; 
        // set SPP / MPP = previous mode
        status = (status &amp; !MASK_PP) | (mode &lt;&lt; pp_i);
        self.csr.store(STATUS, status);
    }
}
</code></pre>
<p>We have also implemented a function <code>check_pending_interrupt</code> for checking whether there is a pending interrupt. </p>
<p>此外，我们需要实现一个函数来检查是否有中断需要处理。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    pub fn check_pending_interrupt(&amp;mut self) -&gt; Option&lt;Interrupt&gt; {
        use Interrupt::*;
        if (self.mode == Machine) &amp;&amp; (self.csr.load(MSTATUS) &amp; MASK_MIE) == 0 {
            return None;
        }
        if (self.mode == Supervisor) &amp;&amp; (self.csr.load(SSTATUS) &amp; MASK_SIE) == 0 {
            return None;
        }
        
        // In fact, we should using priority to decide which interrupt should be handled first.
        if self.bus.uart.is_interrupting() {
            self.bus.store(PLIC_SCLAIM, 32, UART_IRQ).unwrap();
            self.csr.store(MIP, self.csr.load(MIP) | MASK_SEIP); 
        } 
        // 3.1.9 &amp; 4.1.3
        // Multiple simultaneous interrupts destined for M-mode are handled in the following decreasing
        // priority order: MEI, MSI, MTI, SEI, SSI, STI.
        let pending = self.csr.load(MIE) &amp; self.csr.load(MIP);

        if (pending &amp; MASK_MEIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_MEIP);
            return Some(MachineExternalInterrupt);
        }
        if (pending &amp; MASK_MSIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_MSIP);
            return Some(MachineSoftwareInterrupt);
        }
        if (pending &amp; MASK_MTIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_MTIP);
            return Some(MachineTimerInterrupt);
        }
        if (pending &amp; MASK_SEIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_SEIP);
            return Some(SupervisorExternalInterrupt);
        }
        if (pending &amp; MASK_SSIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_SSIP);
            return Some(SupervisorSoftwareInterrupt);
        }
        if (pending &amp; MASK_STIP) != 0 {
            self.csr.store(MIP, self.csr.load(MIP) &amp; !MASK_STIP);
            return Some(SupervisorTimerInterrupt);
        }
        return None;
    }
}
</code></pre>
<p>Finally, we handle an interrupt (if any) at the end of the execution loop.</p>
<p>最后，我们在执行循环中添加对中断的处理。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">main() {
    // ...
    loop {
        let inst = match cpu.fetch() {
            Ok(inst) =&gt; inst,
            Err(e) =&gt; {
                cpu.handle_exception(e);
                if e.is_fatal() {
                    println!(&quot;{}&quot;, e);
                    break;
                }
                continue;
            }
        };

        match cpu.execute(inst) {
            Ok(new_pc) =&gt; cpu.pc = new_pc,
            Err(e) =&gt; {
                cpu.handle_exception(e);
                if e.is_fatal() {
                    println!(&quot;{}&quot;, e);
                    break;
                }
            }
        };

        match cpu.check_pending_interrupt() {
            Some(interrupt) =&gt; cpu.handle_interrupt(interrupt),
            None =&gt; (),
        }
    }
}
</code></pre>
<h3 id="4-conclusion"><a class="header" href="#4-conclusion">4. Conclusion</a></h3>
<p>We have dived into the details of how RISC-V handle interrupt in this chapter. Sometimes, exception and interrupt is considered confusing. I hope this chapter and chapter 5 will help you to distinguish them. Next chapter, we will take about VirtIO, a virtual device family containing a virtual disk that we can perform disk IO on it.</p>
<p>在本章中，我们探索了 RISC-V 处理中断的细节。有时候，异常和中断会让人有点混淆。我希望本章和第五章能够帮你理清它们的区别。在下一章，我们会讨论 virtIO。virtIO 是一个虚拟设备家族，其中包括了一个虚拟磁盘，我们将在上面执行相关的 IO 指令。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="v7-Uart.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="v9-Virtio.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="v7-Uart.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="v9-Virtio.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

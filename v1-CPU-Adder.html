<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adder - Rare: Rust A Riscv Emulator</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Rust A RISC-V Emulator</a></li><li class="chapter-item expanded "><a href="v1-CPU-Adder.html" class="active"><strong aria-hidden="true">1.</strong> Adder</a></li><li class="chapter-item expanded "><a href="v2-Memory-and-Bus.html"><strong aria-hidden="true">2.</strong> Memory and Bus</a></li><li class="chapter-item expanded "><a href="v3-CSR.html"><strong aria-hidden="true">3.</strong> Control Status Register</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rare: Rust A Riscv Emulator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adder"><a class="header" href="#adder">Adder</a></h1>
<p>CPU (Center Process Unit) is one of the core components of a computer. But in this chapter, we will use <code>CPU</code> to denote the whole computer, including 32 common integer registers, a program counter register and a DARM (dynamic random-access memory). In next chapter, we will use bus to connect memory and CPU.</p>
<p>This chapter corresponds to the first chapter <em>CPU with Two instructions</em> of the original tutorial by Asami. When finished, our CPU is able to run two instructions: <code>add</code> and <code>addi</code>.</p>
<p>CPU 指中心处理单元（Center Process Unit），是一块小小的芯片。它是计算机（computer）最核心的部分。</p>
<p>不过，为了简单起见，第一节的 CPU 代指的是整个计算机，它包含了 32 个通用寄存器、一个 PC 寄存器和一块内存。在下一节，我们会将内存移出 CPU。</p>
<p>本节对应原作者的第一节，CPU with Two instructions。这一节的 CPU 只能执行 <code>add</code> 和 <code>addi</code> 两个指令。</p>
<h3 id="1-basic-cpu"><a class="header" href="#1-basic-cpu">1. Basic CPU</a></h3>
<p>Let's define our CPU as follow: It consist of a 64-bit pc register, 32 64-bit integer registers and a DRAM as a vector of u8.</p>
<p>首先定义 CPU 的结构，它包括一个 64 位的 PC，32 个 64 位的通用整数寄存器以及一个用 u8 向量表示的内存。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">struct Cpu {
    // RISC-V has 32 registers
    regs: [u64; 32],
    // pc register contains the memory address of next instruction
    pc: u64,
    // memory, a byte-array. There is no memory in real CPU.
    dram: Vec&lt;u8&gt;,
}
</code></pre>
<p>We need to define the size of memory to initialize our CPU. Since the stack pointer register <code>sp</code> (aka x2) should point to the top address of DRAM. We initialize the <code>pc</code> to <code>0</code>, means we will start fetch instruction from address 0.</p>
<p>我们需要定义内存的大小来初始化 CPU，因为栈指针 (SP) 需要指向栈顶（内存的最高地址），同时，我们将 PC 置 0，意味着我们的程序将从内存地址 0 处开始执行。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">// init memory as 128MB
pub const DRAM_SIZE: u64 = 1024 * 1024 * 128;

struct Cpu { ... }

impl Cpu {
    fn new(code: Vec&lt;u8&gt;) -&gt; Self {
        let mut regs = [0; 32];
        regs[2] = DRAM_SIZE - 1;
        Self {regs, pc: 0, dram: code}
    }
}
</code></pre>
<h3 id="2-cpu-pipeline"><a class="header" href="#2-cpu-pipeline">2. CPU pipeline</a></h3>
<p>Modern CPU spills its execution procedure into several stages to improve throughput and performance. Here is the classic MIPS five-stage pipeline. It consists of:</p>
<ol>
<li>fetch: fetch instruction from memory according to the value of <code>pc</code> register.</li>
<li>decode: decode instruction so the CPU knows how to execute it.</li>
<li>execute: do some computation and get the result.</li>
<li>memory access: store value into memory if necessary. </li>
<li>write back: update PC and register file.</li>
</ol>
<p>CPU do such things again and again.</p>
<p>现代CPU通过将其工作流程划分成多个子过程，以提升其吞吐量和性能。经典的 MIPS 流水线架构包含以下五个部分</p>
<ol>
<li>取指：根据<code>pc</code>值读取内存中的指令 (fetch)</li>
<li>解码：解码指令 (decode)</li>
<li>执行：执行指令 (execute)</li>
<li>访存：将结果写回内存 (memory access)</li>
<li>写回：将运算结果（包括新的PC值）写回寄存器 (write back)</li>
</ol>
<p>周而复始。</p>
<p><img src="./images/cpu-pipeline.png" alt="cpu-pipeline.png" /></p>
<p class=comment>classic MIPS Pipeline</p>
<h3 id="3-instruction-fetch"><a class="header" href="#3-instruction-fetch">3. Instruction fetch</a></h3>
<p>Let's implement the <code>fetch</code> stage firstly.</p>
<p>首先是取指的实现。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    fn fetch(&amp;self) -&gt; u32 {
        let index = self.pc as usize;
        let inst = self.dram[index] as u32 
                | ((self.dram[index + 1] as u32) &lt;&lt; 8)
                | ((self.dram[index + 2] as u32) &lt;&lt; 16)
                | ((self.dram[index + 3] as u32) &lt;&lt; 24);
        return inst;
    }
}
</code></pre>
<p>CPU use <code>pc</code> as a base address to fetch 4 continous bytes from DRAM, since RISC-V instruction is 32-bit. Here, we read the <code>u8</code> on [pc, pc+1, pc+2, pc+3] and build up a <code>u32</code>. What we should be careful is the endianness, which is the term refers to how binary data is stored. There are two types of endianness: little-endianness and big-endianness.</p>
<p>For a multi-byte value, little-endianness stores the least-significant byte at the lowest address and the most-significant byte at the highest address, while big-endianness does the opposite.</p>
<p>Although RISC-V supports endianness settings for memory operation, instructions are uniformly little-endian for the benefit of both hardware and software. See RISC-V-Privileged section 3.1.6.4.</p>
<p>CPU 将<code>pc</code>的值发送给内存，内存返回对应的地址上的值。由于 RISC-V 指令是 32 位的，因此，内存需要读取的是 [pc, pc+1, pc+2, pc+3] 这四个地址上的值，并组合成一个 32 位的指令。这里有一个大端字节序 (big-endian) 与小端字节序 (small-endian) 的问题。</p>
<p>小端字节序指的是，一个由多个字节组成的数，它的最低位字节存储于内存中的低地址处，最高位字节存储于内存中的高地址处。大端则与之相反。</p>
<p>在本实现中，我们采用小端字节序。在 RISC-V 标准中，指令读取是小端字节序，而内存的加载和储存（memory load and store）则可以通过设置<code>mstatus</code>寄存器上特定的位来控制字节序。</p>
<p><img src="./images/endianness.jpg" alt="endianness" /></p>
<p class="comment">Picture from original author</p>
<h3 id="4-instruction-decode"><a class="header" href="#4-instruction-decode">4. Instruction decode</a></h3>
<p>The next stage is instruction decode. In real hardware with pipeline, decoding is a separate step. CPU will fetch next instruction while decoding the current one. But in our emulator, we will simpify these stages by merging decode stage, execute stage and memory access stage into a function <code>execute</code>.</p>
<p>There are four basic encoding format in RISC-V. (There are six if we count for the another two variants.) </p>
<p>读取指令后就要进行解码。在实际的硬件中，解码是一个独立的步骤，芯片会同时读取和解码多个指令 (pipeline parallel) 以提高运行速度。但在我们的模拟器中，一次只读一个指令，可以将这两部分合并在一起。</p>
<p>我们先看解码过程。Riscv 目前有四种基本的指令编码格式（包含变体共有6种），</p>
<p><img src="./images/inst-type.png" alt="inst-type" /></p>
<p class="comment">Picture from original author</p>
<p>现在我们的 CPU 只执行<code>add</code>、<code>addi</code>，它们的功能说明和指令格式如下：</p>
<p><img src="./images/add-addi.png" alt="add-addi" /></p>
<p class="comment">Picture from RISC-V Reader</p>
<p>Designers of RISC-V choose the encoding types carefully to simplify hardware design. All the instructions are 32-bit and the register index is encoding into the same position of different type, which explains why the immediate is spilled into several part in some type.</p>
<p>When implementing, we can firstly decode the instruction as R-type, then decode other information in specific context when necessary. For example, we will decode <code>imm</code> of <code>addi</code> in its decoding branch.</p>
<p>RISC-V 的设计者出于简化硬件的考虑，将所有的指令编码设计成整齐的 32 位长度。寄存器的编码也尽可能地位于相同的位置，这也是为什么立即数会被切分成多个部分进行编码的原因。</p>
<p>因为各个指令格式都有相同的部分，我们不妨先按 R-type 进行解码。对于其他的类型，则在其具体的分支中进一步解码。比如说，<code>addi</code>的<code>imm</code>将会在它的处理分支中进行解码。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    fn execute(&amp;mut self, inst: u32) {
        // decode as R-type
        let opcode = inst &amp; 0x7f;
        let rd = ((inst &gt;&gt; 7) &amp; 0x1f) as usize;
        let rs1 = ((inst &gt;&gt; 15) &amp; 0x1f) as usize;
        let rs2 = ((inst &gt;&gt; 20) &amp; 0x1f) as usize;
        let funct3 = (inst &gt;&gt; 12) &amp; 0x7;
        let funct7 = (inst &gt;&gt; 25) &amp; 0x7f;

        // x0 is hardwired zero
        self.regs[0] = 0;

        // execute stage
        match opcode {
            0x13 =&gt; {
                // addi
                let imm = ((inst &amp; 0xfff0_0000) as i64 &gt;&gt; 20) as u64;
                self.regs[rd] = self.regs[rs1].wrapping_add(imm);
            }
            0x33 =&gt; {
                // add
                self.regs[rd] = self.regs[rs1].wrapping_add(self.regs[rs2]);
            }

            _ =&gt; {
                dbg!(format!(&quot;Invalid opcode: {:#x}&quot;, opcode)); 
            }
        }
    }
}
</code></pre>
<p>Here, we use <code>wrapping_add</code> insteal of <code>+</code> because RISC-V ignore arithmetic overflow.</p>
<p>Now, our CPU is almost finished. We provide a function to help us to inspect the status of our CPU.</p>
<p>这里，我们使用 <code>wrapping_add</code> 的原因在于，这两个指令忽略算术溢出错误(arithmetic overflow)，溢出的位(bit)会被直接丢弃（见上面关于这两个指令的说明）。</p>
<p>CPU 的功能基本上完成了。但我们需要能够方便地查看寄存器的状态，以便验证 CPU 是否正确执行了指令。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    pub fn dump_registers(&amp;self) {
        let mut output = String::new();
        let abi = [
            &quot;zero&quot;, &quot; ra &quot;, &quot; sp &quot;, &quot; gp &quot;, &quot; tp &quot;, &quot; t0 &quot;, &quot; t1 &quot;, &quot; t2 &quot;, 
            &quot; s0 &quot;, &quot; s1 &quot;, &quot; a0 &quot;, &quot; a1 &quot;, &quot; a2 &quot;, &quot; a3 &quot;, &quot; a4 &quot;, &quot; a5 &quot;, 
            &quot; a6 &quot;, &quot; a7 &quot;, &quot; s2 &quot;, &quot; s3 &quot;, &quot; s4 &quot;, &quot; s5 &quot;, &quot; s6 &quot;, &quot; s7 &quot;, 
            &quot; s8 &quot;, &quot; s9 &quot;, &quot; s10&quot;, &quot; s11&quot;, &quot; t3 &quot;, &quot; t4 &quot;, &quot; t5 &quot;, &quot; t6 &quot;,
        ];
        
        for i in (0..32).step_by(4) {
            let i0 = format!(&quot;x{}&quot;, i);
            let i1 = format!(&quot;x{}&quot;, i + 1); 
            let i2 = format!(&quot;x{}&quot;, i + 2);
            let i3 = format!(&quot;x{}&quot;, i + 3); 
            let line = format!(
                &quot;{:3}({}) = {:&lt;#18x} {:3}({}) = {:&lt;#18x} {:3}({}) = {:&lt;#18x} {:3}({}) = {:&lt;#18x}\n&quot;,
                i0, abi[i], self.regs[i], 
                i1, abi[i + 1], self.regs[i + 1], 
                i2, abi[i + 2], self.regs[i + 2], 
                i3, abi[i + 3], self.regs[i + 3],
            );
            output = output + &amp;line;
        }

        println!(&quot;{}&quot;, output);
    }
}
</code></pre>
<h3 id="5-testing"><a class="header" href="#5-testing">5. Testing</a></h3>
<p>Here, we will simply validate our implementation by executing a pure RISC-V binary. Create a file <code>add-addi.s</code> and append the following code.</p>
<p>我们通过执行一个 RISC-V 二进制文件来验证我们的实现。</p>
<p>创建<code>add-addi.s</code>，写入以下内容</p>
<pre><code class="language-s">addi x29, x0, 5
addi x30, x0, 37
add x31, x30, x29
</code></pre>
<p>We run the following command to generate the pure RISC-V binary, aka the binary file without any header.</p>
<p>生成 RISC-V 二进制文件</p>
<pre><code class="language-bash">clang -Wl,-Ttext=0x0 -nostdlib --target=riscv64 -march=rv64g -mno-relax -o add-addi add-addi.s
llvm-objcopy -O binary add-addi add-addi.bin
</code></pre>
<p>At the same time, we need some code to read data from the binary file <code>add-addi.bin</code>. Then we initialize our CPU with the code and execute every instruction in it. Finally, we dump out the register information and exit.</p>
<p>同时，模拟器需要读取<code>add-addi.bin</code>的内容，并初始化一个 CPU 实例。CPU 逐个读取和执行每个指令，最后打印寄存器状态。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">use std::env;
use std::fs::File;
use std::io;
use std::io::prelude::*;

// ...

fn main() -&gt; io::Result&lt;()&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();

    if args.len() != 2 {
        println!(
            &quot;Usage:\n\
            - cargo run &lt;filename&gt;&quot;
        );
        return Ok(());
    }

    let mut file = File::open(&amp;args[1])?;
    let mut code = Vec::new();
    file.read_to_end(&amp;mut code)?;

    let mut cpu = Cpu::new(code);


    while cpu.pc &lt; cpu.dram.len() as u64 {
        let inst = cpu.fetch();
        cpu.execute(inst);
        cpu.pc += 4;
    }
    cpu.dump_registers();

    Ok(())
}
</code></pre>
<p>You are expected to see the <code>x31</code> register own the value <code>0x2a</code> if you execute the following command.</p>
<p>执行以下命令， 应该能够从控制台的输出中看到<code>x31</code>的值为<code>0x2a</code>。</p>
<pre><code class="language-bash">cargo run add-addi.bin
</code></pre>
<h3 id="6-conclusion"><a class="header" href="#6-conclusion">6. Conclusion</a></h3>
<p>We have implemented a adder CPU, it can execute two RISC-V instruction: <code>addi</code>, <code>add</code>. We learn the CPU work process. In next chapter, we will separate the DRAM from CPU and use a bus to connect them. And we will supports more instruction and build a test framework.</p>
<p>我们实现了一个加法器 CPU，它可以执行两个 RISC-V 指令，<code>addi</code>，<code>add</code>。我们还学习了 CPU 的执行步骤：取指令，解码，执行，更新ＰＣ。下一节，我们将内存从ＣＰＵ中剥离，并添加更多的指令支持和一个测试的框架。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="v2-Memory-and-Bus.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="v2-Memory-and-Bus.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

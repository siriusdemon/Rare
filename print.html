<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rare: Rust A Riscv Emulator</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Rust A RISC-V Emulator</a></li><li class="chapter-item expanded "><a href="v1-CPU-Adder.html"><strong aria-hidden="true">1.</strong> Adder</a></li><li class="chapter-item expanded "><a href="v2-Memory-and-Bus.html"><strong aria-hidden="true">2.</strong> Memory and Bus</a></li><li class="chapter-item expanded "><a href="v3-CSR.html"><strong aria-hidden="true">3.</strong> Control Status Register</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rare: Rust A Riscv Emulator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rare-rust-a-risc-v-emulator"><a class="header" href="#rare-rust-a-risc-v-emulator">Rare: Rust A RISC-V Emulator</a></h1>
<p>RISC-V 模拟器教程</p>
<p>This tutorial is based on <a href="https://book.rvemu.app">Asami's excellent tutorial</a>. Although the author haven't finished it, she have already separated the code into 10 stages, which makes this tutorial become possible.</p>
<p>When you complete this tutorial, the emulator is able to run xv6, a UNIX-like operation system running on RISC-V.</p>
<p>I am planning to follow her code build the emulator step by step. When finished, I will write a complete tutorial to help reader to get the details. My tutorial will use the same tool <code>mdbook</code> as the original author, to build.</p>
<ul>
<li>Project: <a href="https://github.com/siriusdemon/Rare">Github Rare</a></li>
<li>Tutorial: <a href="https://siriusdemon.github.io/Rare/">Github.io Rare</a></li>
</ul>
<p>本教程基于<a href="https://github.com/d0iasm">Asami</a> 所写的模拟器<a href="https://book.rvemu.app/">教程</a>。虽然作者只写到第三章，但她已经事先将所有的代码划分成了十个章节。所以看着代码也能够一步一步地构建出这个模拟器。</p>
<p>最终的模拟器可以运行 <a href="https://pdos.csail.mit.edu/6.828/2012/xv6.html">xv6</a> 操作系统。</p>
<p>我的计划是：跟着她的代码和教程一步一步地做出这个模拟器，然后写一个系列完整的中文教程加以说明。该教程与原作一样，使用<a href="https://github.com/rust-lang/mdBook">mdbook</a>构建。</p>
<ul>
<li>项目地址：<a href="https://github.com/siriusdemon/Rare">Github Rare</a></li>
<li>在线教程：<a href="https://siriusdemon.github.io/Rare/">Github.io Rare</a></li>
</ul>
<h3 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h3>
<p>前置</p>
<p>This tutorial assumes readers already have been familiar with <code>Rust</code> and <code>RISC-V</code>. If not, you might want to read the following materials to learn about <code>RISC-V</code>.</p>
<p>本教程假设读者已经对 Rust 和 Riscv 有一定的了解，因此教程中不会对 Rust &amp; Riscv 作过多的解释，而是专注于模拟器本身。推荐通过阅读以下资料来了解 Riscv。</p>
<ul>
<li><a href="https://riscv.org/technical/specifications/">RISC-V Specifications</a></li>
<li><a href="https://zh.webbooksnow.art/dl/16429281/d4417e">RISC-V Reader</a></li>
<li><a href="https://zh.webbooksnow.art/book/18067855/bd7a8a">手把手教你设计RISC-V处理器</a></li>
</ul>
<p>For <code>Rust</code>, you can read <code>the book</code> after you have installed the toolchain. Open your terminal and type <code>rustup docs</code>, your browser will open a new page for you to navigate to <code>the book</code> and other docs.</p>
<p>至于 Rust，安装好环境之后，可以通过运行 <code>rustup docs</code> 来访问<code>the book</code>以及 Rust 文档。</p>
<h3 id="develop-envrionment"><a class="header" href="#develop-envrionment">Develop envrionment</a></h3>
<p>开发环境</p>
<ul>
<li>Linux / WSL</li>
</ul>
<p>We nned the <code>clang</code> toolchain to generate some files used in testing. You can download the precompiled version from <a href="(https://releases.llvm.org/)">here</a>. The version I used is <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.0">clang-12</a>.</p>
<p>我们需要用到 clang 的工具来生成测试的二进制文件，可以从<a href="https://releases.llvm.org/">LLVM</a>官网下载预编译版本。我使用的版本是 <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.0">clang-12</a>，更新的版本应该也可以。</p>
<h3 id="how-to-use"><a class="header" href="#how-to-use">How to use</a></h3>
<ul>
<li>clone this project</li>
<li>use <code>cd Rare/book &amp;&amp; mdbook serve</code> to open this tutorial locally</li>
<li>use <code>git pull</code> to update when needed</li>
</ul>
<p>推荐的使用方法</p>
<ul>
<li>clone 该项目到本地</li>
<li>cd Rare/book &amp;&amp; mdbook serve 打开本地教程</li>
<li>需要的时候，使用 git pull 更新</li>
</ul>
<h3 id="catelogue"><a class="header" href="#catelogue">Catelogue</a></h3>
<p>目录</p>
<ol>
<li><input disabled="" type="checkbox" checked=""/>
<a href="./v1-CPU-Adder.html">Adder 加法器</a></li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="./v2-Memory-and-Bus.html">Memory and Bus 内存和总线</a></li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="./v3-CSR.html">Control Status Register 控制状态寄存器</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v4-privilege-mode.html">Privilege Mode 特权模式</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v5-exceptions.html">Exception 异常</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v6-plic-clint.html">PLIC &amp; CLINT</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v7-uart.html">UART</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v8-interrupts.html">Interrupt 中断</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v9-virtio.html">Virtio</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./v10-page-table.html">Page Table 页表</a></li>
</ol>
<p>The original author separate the tutorial into two parts: Hardware and ISA. I have merged them here. </p>
<p>原作者划分了硬件和 ISA 指令集两部分内容，我觉得合并成一个更适合，所以进行了合并。</p>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>When you travel through this tutorial, sometimes, you may notice some code in current chapter is different from last one's. This is because I will do some refactor when needed. Welcome to open an issue on github if you have any questions.</p>
<p>实践的过程中，读者可能会发现本章的部分代码与上一章的不一样。这是因为我在编写的过程中会适当地进行重构。如有任何疑惑，欢迎在项目上提 issue。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adder"><a class="header" href="#adder">Adder</a></h1>
<p>CPU (Center Process Unit) is one of the core components of a computer. But in this chapter, we will use <code>CPU</code> to denote the whole computer, including 32 common integer registers, a program counter register and a DARM (dynamic random-access memory). In next chapter, we will use bus to connect memory and CPU.</p>
<p>This chapter corresponds to the first chapter <em>CPU with Two instructions</em> of the original tutorial by Asami. When finished, our CPU is able to run two instructions: <code>add</code> and <code>addi</code>.</p>
<p>CPU 指中心处理单元（Center Process Unit），是一块小小的芯片。它是计算机（computer）最核心的部分。</p>
<p>不过，为了简单起见，第一节的 CPU 代指的是整个计算机，它包含了 32 个通用寄存器、一个 PC 寄存器和一块内存。在下一节，我们会将内存移出 CPU。</p>
<p>本节对应原作者的第一节，CPU with Two instructions。这一节的 CPU 只能执行 <code>add</code> 和 <code>addi</code> 两个指令。</p>
<h3 id="1-basic-cpu"><a class="header" href="#1-basic-cpu">1. Basic CPU</a></h3>
<p>Let's define our CPU as follow: It consist of a 64-bit pc register, 32 64-bit integer registers and a DRAM as a vector of u8.</p>
<p>首先定义 CPU 的结构，它包括一个 64 位的 PC，32 个 64 位的通用整数寄存器以及一个用 u8 向量表示的内存。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">struct Cpu {
    // RISC-V has 32 registers
    regs: [u64; 32],
    // pc register contains the memory address of next instruction
    pc: u64,
    // memory, a byte-array. There is no memory in real CPU.
    dram: Vec&lt;u8&gt;,
}
</code></pre>
<p>We need to define the size of memory to initialize our CPU. Since the stack pointer register <code>sp</code> (aka x2) should point to the top address of DRAM. We initialize the <code>pc</code> to <code>0</code>, means we will start fetch instruction from address 0.</p>
<p>我们需要定义内存的大小来初始化 CPU，因为栈指针 (SP) 需要指向栈顶（内存的最高地址），同时，我们将 PC 置 0，意味着我们的程序将从内存地址 0 处开始执行。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">// init memory as 128MB
pub const DRAM_SIZE: u64 = 1024 * 1024 * 128;

struct Cpu { ... }

impl Cpu {
    fn new(code: Vec&lt;u8&gt;) -&gt; Self {
        let mut regs = [0; 32];
        regs[2] = DRAM_SIZE - 1;
        Self {regs, pc: 0, dram: code}
    }
}
</code></pre>
<h3 id="2-cpu-pipeline"><a class="header" href="#2-cpu-pipeline">2. CPU pipeline</a></h3>
<p>Modern CPU spills its execution procedure into several stages to improve throughput and performance. Here is the classic MIPS five-stage pipeline. It consists of:</p>
<ol>
<li>fetch: fetch instruction from memory according to the value of <code>pc</code> register.</li>
<li>decode: decode instruction so the CPU knows how to execute it.</li>
<li>execute: do some computation and get the result.</li>
<li>memory access: store value into memory if necessary. </li>
<li>write back: update PC and register file.</li>
</ol>
<p>CPU do such things again and again.</p>
<p>现代CPU通过将其工作流程划分成多个子过程，以提升其吞吐量和性能。经典的 MIPS 流水线架构包含以下五个部分</p>
<ol>
<li>取指：根据<code>pc</code>值读取内存中的指令 (fetch)</li>
<li>解码：解码指令 (decode)</li>
<li>执行：执行指令 (execute)</li>
<li>访存：将结果写回内存 (memory access)</li>
<li>写回：将运算结果（包括新的PC值）写回寄存器 (write back)</li>
</ol>
<p>周而复始。</p>
<p><img src="./images/cpu-pipeline.png" alt="cpu-pipeline.png" /></p>
<p class=comment>classic MIPS Pipeline</p>
<h3 id="3-instruction-fetch"><a class="header" href="#3-instruction-fetch">3. Instruction fetch</a></h3>
<p>Let's implement the <code>fetch</code> stage firstly.</p>
<p>首先是取指的实现。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    fn fetch(&amp;self) -&gt; u32 {
        let index = self.pc as usize;
        let inst = self.dram[index] as u32 
                | ((self.dram[index + 1] as u32) &lt;&lt; 8)
                | ((self.dram[index + 2] as u32) &lt;&lt; 16)
                | ((self.dram[index + 3] as u32) &lt;&lt; 24);
        return inst;
    }
}
</code></pre>
<p>CPU use <code>pc</code> as a base address to fetch 4 continous bytes from DRAM, since RISC-V instruction is 32-bit. Here, we read the <code>u8</code> on [pc, pc+1, pc+2, pc+3] and build up a <code>u32</code>. What we should be careful is the endianness, which is the term refers to how binary data is stored. There are two types of endianness: little-endianness and big-endianness.</p>
<p>For a multi-byte value, little-endianness stores the least-significant byte at the lowest address and the most-significant byte at the highest address, while big-endianness does the opposite.</p>
<p>In our emulator, we will adopt little-endianness. Although RISC-V supports endianness settings for memory operation, instructions are uniformly little-endian for the benefit of both hardware and software. See RISC-V-Privileged section 3.1.6.4.</p>
<p>CPU 将<code>pc</code>的值发送给内存，内存返回对应的地址上的值。由于 RISC-V 指令是 32 位的，因此，内存需要读取的是 [pc, pc+1, pc+2, pc+3] 这四个地址上的值，并组合成一个 32 位的指令。这里有一个大端字节序 (big-endian) 与小端字节序 (small-endian) 的问题。</p>
<p>小端字节序指的是，一个由多个字节组成的数，它的最低位字节存储于内存中的低地址处，最高位字节存储于内存中的高地址处。大端则与之相反。</p>
<p>在本实现中，我们采用小端字节序。在 RISC-V 标准中，指令读取是小端字节序，而内存的加载和储存（memory load and store）则可以通过设置<code>mstatus</code>寄存器上特定的位来控制字节序。</p>
<p><img src="./images/endianness.jpg" alt="endianness" /></p>
<p class="comment">Picture from original author</p>
<h3 id="4-instruction-decode"><a class="header" href="#4-instruction-decode">4. Instruction decode</a></h3>
<p>The next stage is instruction decode. In real hardware with pipeline, decoding is a separate step. CPU will fetch next instruction while decoding the current one. But in our emulator, we will simpify these stages by merging decode stage, execute stage and memory access stage into a function <code>execute</code>.</p>
<p>There are four basic encoding format in RISC-V. (There are six if we count for the another two variants.) </p>
<p>读取指令后就要进行解码。在实际的硬件中，解码是一个独立的步骤，芯片会同时读取和解码多个指令 (pipeline parallel) 以提高运行速度。但在我们的模拟器中，一次只读一个指令，可以将这两部分合并在一起。</p>
<p>我们先看解码过程。Riscv 目前有四种基本的指令编码格式（包含变体共有6种），</p>
<p><img src="./images/inst-type.png" alt="inst-type" /></p>
<p class="comment">Picture from original author</p>
<p>现在我们的 CPU 只执行<code>add</code>、<code>addi</code>，它们的功能说明和指令格式如下：</p>
<p><img src="./images/add-addi.png" alt="add-addi" /></p>
<p class="comment">Picture from RISC-V Reader</p>
<p>Designers of RISC-V choose the encoding types carefully to simplify hardware design. All the instructions are 32-bit and the register index is encoding into the same position of different type, which explains why the immediate is spilled into several part in some type.</p>
<p>When implementing, we can firstly decode the instruction as R-type, then decode other information in specific context when necessary. For example, we will decode <code>imm</code> of <code>addi</code> in its decoding branch.</p>
<p>RISC-V 的设计者出于简化硬件的考虑，将所有的指令编码设计成整齐的 32 位长度。寄存器的编码也尽可能地位于相同的位置，这也是为什么立即数会被切分成多个部分进行编码的原因。</p>
<p>因为各个指令格式都有相同的部分，我们不妨先按 R-type 进行解码。对于其他的类型，则在其具体的分支中进一步解码。比如说，<code>addi</code>的<code>imm</code>将会在它的处理分支中进行解码。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    fn execute(&amp;mut self, inst: u32) {
        // decode as R-type
        let opcode = inst &amp; 0x7f;
        let rd = ((inst &gt;&gt; 7) &amp; 0x1f) as usize;
        let rs1 = ((inst &gt;&gt; 15) &amp; 0x1f) as usize;
        let rs2 = ((inst &gt;&gt; 20) &amp; 0x1f) as usize;
        let funct3 = (inst &gt;&gt; 12) &amp; 0x7;
        let funct7 = (inst &gt;&gt; 25) &amp; 0x7f;

        // x0 is hardwired zero
        self.regs[0] = 0;

        // execute stage
        match opcode {
            0x13 =&gt; {
                // addi
                let imm = ((inst &amp; 0xfff0_0000) as i64 &gt;&gt; 20) as u64;
                self.regs[rd] = self.regs[rs1].wrapping_add(imm);
            }
            0x33 =&gt; {
                // add
                self.regs[rd] = self.regs[rs1].wrapping_add(self.regs[rs2]);
            }

            _ =&gt; {
                dbg!(format!(&quot;Invalid opcode: {:#x}&quot;, opcode)); 
            }
        }
    }
}
</code></pre>
<p>Here, we use <code>wrapping_add</code> insteal of <code>+</code> because RISC-V ignore arithmetic overflow.</p>
<p>Now, our CPU is almost finished. We provide a function to help us to inspect the status of our CPU.</p>
<p>这里，我们使用 <code>wrapping_add</code> 的原因在于，这两个指令忽略算术溢出错误(arithmetic overflow)，溢出的位(bit)会被直接丢弃（见上面关于这两个指令的说明）。</p>
<p>CPU 的功能基本上完成了。但我们需要能够方便地查看寄存器的状态，以便验证 CPU 是否正确执行了指令。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">const RVABI: [&amp;str; 32] = [
    &quot;zero&quot;, &quot;ra&quot;, &quot;sp&quot;, &quot;gp&quot;, &quot;tp&quot;, &quot;t0&quot;, &quot;t1&quot;, &quot;t2&quot;, 
    &quot;s0&quot;, &quot;s1&quot;, &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;, 
    &quot;a6&quot;, &quot;a7&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;, 
    &quot;s8&quot;, &quot;s9&quot;, &quot;s10&quot;, &quot;s11&quot;, &quot;t3&quot;, &quot;t4&quot;, &quot;t5&quot;, &quot;t6&quot;,
];

impl Cpu {
    // ...
    pub fn dump_registers(&amp;mut self) {
        println!(&quot;{:-^80}&quot;, &quot;registers&quot;);
        let mut output = String::new();
        self.regs[0] = 0;

        for i in (0..32).step_by(4) {
            let i0 = format!(&quot;x{}&quot;, i);
            let i1 = format!(&quot;x{}&quot;, i + 1); 
            let i2 = format!(&quot;x{}&quot;, i + 2);
            let i3 = format!(&quot;x{}&quot;, i + 3); 
            let line = format!(
                &quot;{:3}({:^4}) = {:&lt;#18x} {:3}({:^4}) = {:&lt;#18x} {:3}({:^4}) = {:&lt;#18x} {:3}({:^4}) = {:&lt;#18x}\n&quot;,
                i0, RVABI[i], self.regs[i], 
                i1, RVABI[i + 1], self.regs[i + 1], 
                i2, RVABI[i + 2], self.regs[i + 2], 
                i3, RVABI[i + 3], self.regs[i + 3],
            );
            output = output + &amp;line;
        }
        println!(&quot;{}&quot;, output);
    }
}
</code></pre>
<h3 id="5-testing"><a class="header" href="#5-testing">5. Testing</a></h3>
<p>Here, we will simply validate our implementation by executing a pure RISC-V binary. Create a file <code>add-addi.s</code> and append the following code.</p>
<p>我们通过执行一个 RISC-V 二进制文件来验证我们的实现。</p>
<p>创建<code>add-addi.s</code>，写入以下内容</p>
<pre><code class="language-s">addi x29, x0, 5
addi x30, x0, 37
add x31, x30, x29
</code></pre>
<p>We run the following command to generate the pure RISC-V binary, aka the binary file without any header.</p>
<p>生成 RISC-V 二进制文件</p>
<pre><code class="language-bash">clang -Wl,-Ttext=0x0 -nostdlib --target=riscv64 -march=rv64g -mno-relax -o add-addi add-addi.s
llvm-objcopy -O binary add-addi add-addi.bin
</code></pre>
<p>At the same time, we need some code to read data from the binary file <code>add-addi.bin</code>. Then we initialize our CPU with the code and execute every instruction in it. Finally, we dump out the register information and exit.</p>
<p>同时，模拟器需要读取<code>add-addi.bin</code>的内容，并初始化一个 CPU 实例。CPU 逐个读取和执行每个指令，最后打印寄存器状态。</p>
<p class="filename">main.rs</p>
<pre><code class="language-rs">use std::env;
use std::fs::File;
use std::io;
use std::io::prelude::*;

// ...

fn main() -&gt; io::Result&lt;()&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();

    if args.len() != 2 {
        println!(
            &quot;Usage:\n\
            - cargo run &lt;filename&gt;&quot;
        );
        return Ok(());
    }

    let mut file = File::open(&amp;args[1])?;
    let mut code = Vec::new();
    file.read_to_end(&amp;mut code)?;

    let mut cpu = Cpu::new(code);

    while cpu.pc &lt; cpu.dram.len() as u64 {
        let inst = cpu.fetch();
        cpu.execute(inst);
        cpu.pc += 4;
    }
    cpu.dump_registers();

    Ok(())
}
</code></pre>
<p>You are expected to see the <code>x31</code> register own the value <code>0x2a</code> if you execute the following command.</p>
<p>执行以下命令， 应该能够从控制台的输出中看到<code>x31</code>的值为<code>0x2a</code>。</p>
<pre><code class="language-bash">cargo run add-addi.bin
</code></pre>
<h3 id="6-conclusion"><a class="header" href="#6-conclusion">6. Conclusion</a></h3>
<p>We have implemented a adder CPU, it can execute two RISC-V instruction: <code>addi</code>, <code>add</code>. We learn the CPU work process. In next chapter, we will separate the DRAM from CPU and use a bus to connect them. And we will supports more instruction and build a test framework.</p>
<p>我们实现了一个加法器 CPU，它可以执行两个 RISC-V 指令，<code>addi</code>，<code>add</code>。我们还学习了 CPU 的执行步骤：取指令，解码，执行，更新ＰＣ。下一节，我们将内存从ＣＰＵ中剥离，并添加更多的指令支持和一个测试的框架。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-and-bus"><a class="header" href="#memory-and-bus">Memory and Bus</a></h1>
<p>内存和总线</p>
<p>In last chapter, our CPU contains a DRAM. But in real hardware, they are connected by the bus and exchange data through the bus.</p>
<p>在上一节，我们把内存和 CPU 放在同一个结构体中，但在真实的硬件中，这两部分是分开的。CPU 和内存通过总线（bus）进行数据交换。如下图所示：</p>
<p><img src="./images/bus.png" alt="bus" /></p>
<p class="comment">Picture from Operation System: Three Easy Pieces</p>
<h3 id="1-connect-cpu-and-dram-by-bus"><a class="header" href="#1-connect-cpu-and-dram-by-bus">1. Connect CPU and DRAM by Bus</a></h3>
<p>Thus, we have defined thw following struct.</p>
<p>因此，我们定义以下结构：</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">pub struct Cpu {
    pub regs: [u64; 32],
    pub pc: u64,
    pub bus: Bus,
}
</code></pre>
<p>Now, CPU contains a bus instead of DRAM. There are possible many devices connected on bus. But we have only one device (DRAM) right now.</p>
<p>CPU 现在不包含内存，而是连接了总线。总线上可能有多个 IO 设备，但目前我们只有一个（DRAM）。</p>
<p class="filename">bus.rs</p>
<pre><code class="language-rs">pub struct Bus {
    dram: Dram,
}
</code></pre>
<p class="filename">dram.rs</>
<pre><code class="language-rs">pub struct Dram {
    pub dram: Vec&lt;u8&gt;,
}
</code></pre>
<h3 id="2-memory-api"><a class="header" href="#2-memory-api">2. Memory API</a></h3>
<p>Memory has two function: <code>store</code> and <code>load</code>. Only store and load a 8-bit, 16-bit, 32-bit and 64-bit are allowed. Recall that we use little-endian byte ordering. We implement the memory API as following:</p>
<p>内存（DRAM）只有两个功能：store，load。保存和读取的有效位数是 8，16，32，64。回顾上一节，我们采用的是小端字节序。实现如下</p>
<p class="filename">dram.rs</>
<pre><code class="language-rs">
impl Dram {
    pub fn new(code: Vec&lt;u8&gt;) -&gt; Dram {
        let mut dram = vec![0; DRAM_SIZE as usize];
        dram.splice(..code.len(), code.into_iter());
        Self { dram }
    }

    // addr/size must be valid. Check in bus
    pub fn load(&amp;self, addr: u64, size: u64) -&gt; Result&lt;u64, Exception&gt; {
        if ![8, 16, 32, 64].contains(&amp;size) {
            return Err(LoadAccessFault(addr));
        }
        let nbytes = size / 8;
        let index = (addr - DRAM_BASE) as usize;
        let mut code = self.dram[index] as u64;
        // shift the bytes to build up the desired value
        for i in 1..nbytes {
            code |= (self.dram[index + i as usize] as u64) &lt;&lt; (i * 8);
        }

        return Ok(code);
    }

    // addr/size must be valid. Check in bus
    pub fn store(&amp;mut self, addr: u64, size: u64, value: u64) -&gt; Result&lt;(), Exception&gt; {
        if ![8, 16, 32, 64].contains(&amp;size) {
            return Err(StoreAMOAccessFault(addr));
        }
        let nbytes = size / 8;
        let index = (addr - DRAM_BASE) as usize;
        for i in 0..nbytes {
            let offset = 8 * i as usize;
            self.dram[index + i as usize] = ((value &gt;&gt; offset) &amp; 0xff) as u8;
        }
        return Ok(())
    }
}
</code></pre>
<p>Here, we have use some global value and <code>Exception</code>. They are in <code>param.rs</code> and <code>exception.rs</code>.  We won't talk about Exception until Chapter 5. For now, we only need three exception type:</p>
<p>这里用到了一些全局变量和异常，定义在 <code>param.rs</code> 和 <code>exception.rs</code> 中，我们将会在第五章的时候讨论异常。现在只需要了解以下三种异常即可。</p>
<ul>
<li>LoadAccessFault</li>
<li>StoreAMOAccessFault</li>
<li>IllegalInstruction</li>
</ul>
<p>Refer to RISC-V Specification if you are curious. 如果你是好奇宝宝，可以去看下 RISC-V 标准。</p>
<p>The <code>param.rs</code> contains the following code. We choose <code>DRAM_BASE</code> the same value, 0x8000_0000, as in qemu. It will be the initial value of the PC register.</p>
<p><code>param.rs</code> 中包含了以下代码。我们选择了跟 QEMU 一样的内存起始地址 0x8000_0000。PC 寄存器初始化的时候会被赋予这个值。</p>
<p class="filename">param.rs</p>
<pre><code class="language-rs">pub const DRAM_BASE: u64 = 0x8000_0000;
pub const DRAM_SIZE: u64 = 1024 * 1024 * 128;
pub const DRAM_END: u64 = DRAM_SIZE + DRAM_BASE - 1;
</code></pre>
<h3 id="3-bus-api"><a class="header" href="#3-bus-api">3. Bus API</a></h3>
<p>Bus is a communication medium of CPU and various IO devices. Bus allocates different address for differet devices. By sending instruction through bus, CPU can operate the IO devices indirectly. </p>
<p>Bus also provides two function: <code>store</code> and <code>load</code>.</p>
<p>总线是 CPU 与各种 IO 设备（如键盘、鼠标、屏幕等）通信的渠道。总线上不同的地址范围对应了不同的设备。CPU 通过给总线发指令来间接操作其他的设备。</p>
<p>总线同样仅提供两个操作：store，load。</p>
<p class="filename">bus.rs</p>
<pre><code class="language-rs">impl Bus {
    pub fn new(code: Vec&lt;u8&gt;) -&gt; Bus {
        Self { dram: Dram::new(code) }
    }
    pub fn load(&amp;mut self, addr: u64, size: u64) -&gt; Result&lt;u64, Exception&gt; {
        match addr {
            DRAM_BASE..=DRAM_END =&gt; self.dram.load(addr, size),
            _ =&gt; Err(Exception::LoadAccessFault(addr)),
        }
    }

    pub fn store(&amp;mut self, addr: u64, size: u64, value: u64) -&gt; Result&lt;(), Exception&gt; {
        match addr {
            DRAM_BASE..=DRAM_END =&gt; self.dram.store(addr, size, value),
            _ =&gt; Err(Exception::StoreAMOAccessFault(addr)),
        }
    }
}
</code></pre>
<h3 id="4-cpu-api"><a class="header" href="#4-cpu-api">4. CPU API</a></h3>
<p>CPU loads and stores data through the bus connected to it. Note that our CPU will start execution at address DRAM_BASE from now on.</p>
<p>现在 CPU 不直接读写内存，而是通过向总线发指令来读写内存。现在我们的 CPU 将会从 DRAM_BASE 处开始执行。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">impl Cpu {
    pub fn new(code: Vec&lt;u8&gt;) -&gt; Self {
        let mut regs = [0; 32];
        regs[2] = DRAM_END;
        let bus = Bus::new(code);
        Self {regs, pc: DRAM_BASE, bus}
    }

    /// Load a value from a dram.
    pub fn load(&amp;mut self, addr: u64, size: u64) -&gt; Result&lt;u64, Exception&gt; {
        self.bus.load(addr, size)
    }

    /// Store a value to a dram.
    pub fn store(&amp;mut self, addr: u64, size: u64, value: u64) -&gt; Result&lt;(), Exception&gt; {
        self.bus.store(addr, size, value)
    }

    /// Get an instruction from the dram.
    pub fn fetch(&amp;mut self) -&gt; Result&lt;u64, Exception&gt; {
        self.bus.load(self.pc, 32)
    } 
}
</code></pre>
<p>Now, we have finished code refactoring. To run the example in last chapter, we have to modify <code>main.rs</code>. You may want to refer the code in according folder.</p>
<p>至此，我们已经完成将内存剥离 CPU 的重构工作。我们需要对<code>main.rs</code>进一步修改，以便成功运行上一节的汇编程序。你可能想参考一下对应文件夹下的代码。</p>
<h3 id="5-return-new-pc-value"><a class="header" href="#5-return-new-pc-value">5. Return new PC value</a></h3>
<p>Recall that, the final stage of a five-stage pipeline introduced in last chapter is <code>Write Back</code>. In this stage, the address of next instruction is written into the PC register. We will imitate such a behaviour by returning a new pc value from the <code>execute</code> function. </p>
<p>We need to do such a change because we are going to support more instructions, including branch instructions, which decides the next PC value according to the condition. We can not simply add 4 get the next PC value right now.</p>
<p>We change our <code>execute</code> function as following:</p>
<p>回顾上一节介绍的五阶段流水线，最后一个阶段是写回。在这个阶段，新的 PC 值会被写回 PC 寄存器。我们通过让 <code>execute</code> 函数返回一个新的 PC 值来模拟这一行为。之所以要这么做，是因为我们准备支持更多的指令，其中包括分支跳转指令。这些指令会改变 PC 的值。因此，我们无法通过原 PC 值加 4 来得到新的 PC 值。
新的 <code>execute</code> 定义如下：</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    pub fn execute(&amp;mut self, inst: u64) -&gt; Result&lt;u64, Exception&gt; { 
        //... 
    }
}
</code></pre>
<p>Besides, we update PC register using the value returned from <code>execute</code> in <code>main.rs</code>:</p>
<p>同时，在<code>main.rs</code>，我们用新的 execute 的返回值来更新 PC 寄存器。</p>
<pre><code class="language-rs">fn main() {
    // ...
    loop {
        let inst = match cpu.fetch() {
            Ok(inst) =&gt; inst,
            Err(e) =&gt; { break; }
        };

        match cpu.execute(inst) {
            Ok(new_pc) =&gt; cpu.pc = new_pc,
            Err(e) =&gt; { break; }
        };
    }
}
</code></pre>
<h3 id="6-support-new-instructions"><a class="header" href="#6-support-new-instructions">6. Support new instructions</a></h3>
<p>We will support following instructions in this chapter.</p>
<p>这一节我们将支持以下指令</p>
<p><img src="./images/rv32-inst.png" alt="rv32" /></p>
<p class="comment">Picture from original author</p>
<p><img src="./images/rv64-inst.png" alt="rv64" /></p>
<p class="comment">Picture from original author</p>
<p>It is impractical to explain every instruction here. <code>RISC-V reader</code> is a helpful reference if you want to implement every instruction by yourself. In fact, I almost copy the code from <a href="https://github.com/d0iasm">Asami</a>, the original author :).  Nevertheless, I have provided a test framework (see below) and you are really encouraged to implement the instruction by yourself.</p>
<p>在教程中逐个解释逐个实现是不切实际的。如果你想自己一个个实现，RISC-V Reader 附录的指令说明会是一个不错的参考。实际上，我基本直接复制了<a href="https://github.com/d0iasm">原作者</a>的代码。尽管如此，我写了一个测试框架（在后文），可以帮助你验证自己的实现。</p>
<h3 id="7-testing"><a class="header" href="#7-testing">7. Testing</a></h3>
<p>We need to add some tests to ensure our implementation is correct. In last chapter, we generate pure RISC-V binary by <code>clang</code> and <code>llvm-objcopy</code>. We will make the following procedure automatically to ease the testing of our code. </p>
<p>我们需要对指令的解释做单元测试，以便我们排查 BUG。在上一节，我们通过<code>clang</code>，<code>llvm-objcopy</code>来生成二进制代码。现在我们将以下过程自动化以便于我们在代码中添加测试。</p>
<pre><code class="language-bash">clang -S simple.c -nostdlib -march=rv64i -mabi=lp64 -mno-relax
clang -Wl,-Ttext=0x0 -nostdlib -march=rv64i -mabi=lp64 -mno-relax -o simple simple.s
llvm-objcopy -O binary simple simple.bin
</code></pre>
<p>The first command generates the assembly code, then the second command generates a binary file in ELF format. Finally, the third command remove the ELF header and a RISC-V pure binary is generated. Implementation is as follow:</p>
<p>其中第一行从C代码中生成汇编代码，第二行编译成了一个ELF格式的二进制文件，第三行去掉了ELF格式，只保存了其中的二进制代码。我们分别实现如下：</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">#[cfg(test)]
mod test {
    use std::fs::File;
    use std::io::{Write, Read};
    use std::process::Command;
    use super::*;

  fn generate_rv_assembly(c_src: &amp;str) {
        let cc = &quot;clang&quot;;
        let output = Command::new(cc).arg(&quot;-S&quot;)
                            .arg(c_src)
                            .arg(&quot;-nostdlib&quot;)
                            .arg(&quot;-march=rv64g&quot;)
                            .arg(&quot;-mabi=lp64&quot;)
                            .arg(&quot;--target=riscv64&quot;)
                            .arg(&quot;-mno-relax&quot;)
                            .output()
                            .expect(&quot;Failed to generate rv assembly&quot;);
        println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;output.stderr));
    }

    fn generate_rv_obj(assembly: &amp;str) {
        let cc = &quot;clang&quot;;
        let pieces: Vec&lt;&amp;str&gt; = assembly.split(&quot;.&quot;).collect();
        let output = Command::new(cc).arg(&quot;-Wl,-Ttext=0x0&quot;)
                            .arg(&quot;-nostdlib&quot;)
                            .arg(&quot;-march=rv64g&quot;)
                            .arg(&quot;-mabi=lp64&quot;)
                            .arg(&quot;--target=riscv64&quot;)
                            .arg(&quot;-mno-relax&quot;)
                            .arg(&quot;-o&quot;)
                            .arg(&amp;pieces[0])
                            .arg(assembly)
                            .output()
                            .expect(&quot;Failed to generate rv object&quot;);
        println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;output.stderr));
    }

    fn generate_rv_binary(obj: &amp;str) {
        let objcopy = &quot;llvm-objcopy&quot;;
        let output = Command::new(objcopy).arg(&quot;-O&quot;)
                                .arg(&quot;binary&quot;)
                                .arg(obj)
                                .arg(obj.to_owned() + &quot;.bin&quot;)
                                .output()
                                .expect(&quot;Failed to generate rv binary&quot;);
        println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;output.stderr));
    }
}
</code></pre>
<p>Aimed with the auxiliary function above, we can let the CPU running up. 有了以上辅助函数之后，我们可以让 CPU 跑起来。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">mod test {
    // ...
       fn rv_helper(code: &amp;str, testname: &amp;str, n_clock: usize) -&gt; Result&lt;Cpu, std::io::Error&gt; {
        let filename = testname.to_owned() + &quot;.s&quot;;
        let mut file = File::create(&amp;filename)?;
        file.write(&amp;code.as_bytes())?;
        generate_rv_obj(&amp;filename);
        generate_rv_binary(testname);
        let mut file_bin = File::open(testname.to_owned() + &quot;.bin&quot;)?;
        let mut code = Vec::new();
        file_bin.read_to_end(&amp;mut code)?;
        let mut cpu = Cpu::new(code);

        for _i in 0..n_clock {
            let inst = match cpu.fetch() {
                Ok(inst) =&gt; inst,
                Err(_err) =&gt; break,
            };
            match cpu.execute(inst) {
                Ok(new_pc) =&gt; cpu.pc = new_pc,
                Err(err) =&gt; println!(&quot;{}&quot;, err),
            };
        }

        return Ok(cpu);
    }
}
</code></pre>
<p>The code above writes the RISC-V assembly code into a file and generate a pure binary file. Then a CPU is created and execute for <code>n_clock</code>. Finally, the CPU is returned because we want to check its status.</p>
<p>Now, we can add a simple test for <code>addi</code>.</p>
<p>以上代码将 Riscv 汇编代码写入文件，并生成相应的二进制代码文件，然后创建一个 CPU 进行执行，最终返回该 CPU 实例。</p>
<p>现在，我们对<code>addi</code>添加一个简单的测试。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">mod test {
    // ...
    #[test]
    fn test_addi() {
        let code = &quot;addi x31, x0, 42&quot;;
        match rv_helper(code, &quot;test_addi&quot;, 1) {
            Ok(cpu) =&gt; assert_eq!(cpu.regs[31], 42),
            Err(e) =&gt; { println!(&quot;error: {}&quot;, e); assert!(false); }
        }
    }
}
</code></pre>
<p>Running the test by 执行测试</p>
<pre><code class="language-sh">cargo test
</code></pre>
<h3 id="8-macro-riscv_test-for-easier-testing"><a class="header" href="#8-macro-riscv_test-for-easier-testing">8. Macro <code>riscv_test</code> for easier testing</a></h3>
<p>We use the following macro to abstract the testing procedure.</p>
<p>以下宏用于简化测试过程。关于宏，我以前在<a href="https://zhuanlan.zhihu.com/p/260707957">一篇博文</a>中写过一段简短的解释。故不赘述。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">mod test {
    // ...
    macro_rules! riscv_test {
        ( $code:expr, $name:expr, $clock:expr, $($real:expr =&gt; $expect:expr),* ) =&gt; {
            match rv_helper($code, $name, $clock) {
                Ok(cpu) =&gt; { 
                    $(assert_eq!(cpu.reg($real), $expect);)*
                }
                Err(e) =&gt; { println!(&quot;error: {}&quot;, e); assert!(false); }
            } 
        };
    }
}
</code></pre>
<p>We need another function for easier register lookup. 我们需要另一个函数来方便我们查看寄存器的值。</p>
<pre><code class="language-rs">impl Cpu {
    // ...
    pub fn reg(&amp;self, r: &amp;str) -&gt; u64 {
        match RVABI.iter().position(|&amp;x| x == r) {
            Some(i) =&gt; self.regs[i],
            None =&gt; match r {
                &quot;pc&quot; =&gt; self.pc,
                &quot;fp&quot; =&gt; self.reg(&quot;s0&quot;),
                r if r.starts_with(&quot;x&quot;) =&gt; {
                    if let Ok(i) = r[1..].parse::&lt;usize&gt;() {
                        if i &lt;= 31 { return self.regs[i]; }
                        panic!(&quot;Invalid register {}&quot;, r);
                    }
                    panic!(&quot;Invalid register {}&quot;, r);
                }
                _ =&gt; panic!(&quot;Invalid register {}&quot;, r),
            }
        }
    }
}
</code></pre>
<p>With the <code>riscv_test</code> macro and <code>reg</code> function, we can simplify the test as follow:</p>
<p>有了 riscv_test 宏以及 reg 函数，以上的测试可以简化成这样：</p>
<pre><code class="language-rs">mod test {
    //...
    #[test]
    fn test_addi() {
        let code = &quot;addi x31, x0, 42&quot;;
        riscv_test!(code, &quot;test_addi&quot;, 1, &quot;x31&quot; =&gt; 42);
    }
}
</code></pre>
<h3 id="9-conclusion"><a class="header" href="#9-conclusion">9. Conclusion</a></h3>
<p>We have performed code refactoring to the CPU structure by using bus to connect the CPU and DRAM. We will add more devices on bus. Besides, we imitate the <code>Write Back</code> stage by returning a new PC value from <code>execute</code>. We also support more instructions and design a test framework to ease testing. On next chapter, we will add the <code>Control Status Register</code> to CPU and support corresponding instruction.</p>
<p>我们重构了 CPU 的结构，总线连接了 CPU 和内存。后续我们还会添加更多的设备到总线上。同时，我们模拟了写回阶段，<code>execute</code>函数返回一个新的PC值用于PC寄存器的更新。此外，我们实现了一个测试框架，便于及时验证我们的实现。在下一节中，我们将添加对控制状态寄存器（Control Status Register）的读写支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-status-register"><a class="header" href="#control-status-register">Control Status Register</a></h1>
<p>RISC-V defines a separate address space of 4096 Control and Status registers associated with each hart. This chapter focuses on the CSR instructions that operate on these CSRs, which are defined in Chapter 9 of RISC-V unprivileged ISA. We will talk more about the functionality of these CSRs in chapter 4 and chapter 5.</p>
<p>RISC-V has defined three privilege level. At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode
in one or more CSRs. We will talk more about privilege levels in next chapter.</p>
<p>RISC-V 为每一个 hart 定义了一个独立的控制状态寄存器的地址空间，有 4096 个之多。本章主要着重于实现相应的指令集，这部分内容在 RISC-V 非特权 ISA 标准的第九章中。我们将会在第四和第五章讨论这些寄存器的功能。</p>
<p>RISC-V 定义了三种特权等级。在任意时刻，一个 hart 总是跑在某种特权等级上。这个特权等级编码在一个或者多个控制状态寄存器之中。我们会在下一章节中讨论特权等级。</p>
<p><img src="./images/privilege-level.png" alt="privilege-level" /></p>
<p class="comment">Picture from RISC-V Privileged</p>
<h3 id="1-csrs"><a class="header" href="#1-csrs">1. CSRs</a></h3>
<p>The table below includes all the CSRs we need in this tutorial. I suggest you stop to read the corresponding chapter in RISC-V privileged if you are curious.</p>
<p>下表基本包含了我们这个小项目需要用到的（也就是 xv6 所需要的）寄存器。你可以停下来去翻翻 RISC-V 特权标准中的相关的章节。</p>
<p><img src="./images/misa-csr.png" alt="misa-csr" /></p>
<p class="comment">Picture from RISC-V Privileged</p>
<p><img src="./images/sisa-csr.png" alt="sisa-csr" /></p>
<p class="comment">Picture from RISC-V Privileged</p>
<p>What I want to point out is that the <code>sie</code>, <code>sip</code> and <code>sstatus</code> is the restricted view of <code>mie</code>, <code>mip</code> and <code>mstatus</code>. In a straightforward implementation, reading or writing any field in sie, sip, sstatus is equivalent to reading or writing the homonymous field in mie, mip and mstatus respectively.</p>
<p>我想指出的是，sie，sip，sstatus 是 mie，mip，mstatus 的子集。在一个简单的实现中，读写 sie，sip，sstatus 中的任意字段相当于读写 mie，mip，mstatus 中对应的字段。</p>
<h3 id="2-csrs-address"><a class="header" href="#2-csrs-address">2. CSRs' address</a></h3>
<p>Firstly, let's record the address of the CSRs we need.</p>
<p>根据上表，我们先录入所需要的寄存器地址。</p>
<p class="filename">csr.rs</p>
<pre><code class="language-rs">pub const MHARTID: usize = 0xf14;
/// Machine status register.
pub const MSTATUS: usize = 0x300;
/// Machine exception delefation register.
pub const MEDELEG: usize = 0x302;
/// Machine interrupt delefation register.
pub const MIDELEG: usize = 0x303;
/// Machine interrupt-enable register.
pub const MIE: usize = 0x304;
/// Machine trap-handler base address.
pub const MTVEC: usize = 0x305;
/// Machine counter enable.
pub const MCOUNTEREN: usize = 0x306;
/// Scratch register for machine trap handlers.
pub const MSCRATCH: usize = 0x340;
/// Machine exception program counter.
pub const MEPC: usize = 0x341;
/// Machine trap cause.
pub const MCAUSE: usize = 0x342;
/// Machine bad address or instruction.
pub const MTVAL: usize = 0x343;
/// Machine interrupt pending.
pub const MIP: usize = 0x344;

// Supervisor-level CSRs.
/// Supervisor status register.
pub const SSTATUS: usize = 0x100;
/// Supervisor interrupt-enable register.
pub const SIE: usize = 0x104;
/// Supervisor trap handler base address.
pub const STVEC: usize = 0x105;
/// Scratch register for supervisor trap handlers.
pub const SSCRATCH: usize = 0x140;
/// Supervisor exception program counter.
pub const SEPC: usize = 0x141;
/// Supervisor trap cause.
pub const SCAUSE: usize = 0x142;
/// Supervisor bad address or instruction.
pub const STVAL: usize = 0x143;
/// Supervisor interrupt pending.
pub const SIP: usize = 0x144;
/// Supervisor address translation and protection.
pub const SATP: usize = 0x180;
</code></pre>
<p>We will need to perform bit-operation on CSRs. So let's define some useful constant here.</p>
<p>我们需要对一些 CSR 做位操作，所以这里先定义一些后面会用到的常量。</p>
<p class="filename">csr.rs</p>
<pre><code class="language-rs">// mstatus and sstatus field mask
pub const MASK_SIE: u64 = 1 &lt;&lt; 1; 
pub const MASK_MIE: u64 = 1 &lt;&lt; 3;
pub const MASK_SPIE: u64 = 1 &lt;&lt; 5; 
pub const MASK_UBE: u64 = 1 &lt;&lt; 6; 
pub const MASK_MPIE: u64 = 1 &lt;&lt; 7;
pub const MASK_SPP: u64 = 1 &lt;&lt; 8; 
pub const MASK_VS: u64 = 0b11 &lt;&lt; 9;
pub const MASK_MPP: u64 = 0b11 &lt;&lt; 11;
pub const MASK_FS: u64 = 0b11 &lt;&lt; 13; 
pub const MASK_XS: u64 = 0b11 &lt;&lt; 15; 
pub const MASK_MPRV: u64 = 1 &lt;&lt; 17;
pub const MASK_SUM: u64 = 1 &lt;&lt; 18; 
pub const MASK_MXR: u64 = 1 &lt;&lt; 19; 
pub const MASK_TVM: u64 = 1 &lt;&lt; 20;
pub const MASK_TW: u64 = 1 &lt;&lt; 21;
pub const MASK_TSR: u64 = 1 &lt;&lt; 22;
pub const MASK_UXL: u64 = 0b11 &lt;&lt; 32; 
pub const MASK_SXL: u64 = 0b11 &lt;&lt; 34;
pub const MASK_SBE: u64 = 1 &lt;&lt; 36;
pub const MASK_MBE: u64 = 1 &lt;&lt; 37;
pub const MASK_SD: u64 = 1 &lt;&lt; 63; 
pub const MASK_SSTATUS: u64 = MASK_SIE | MASK_SPIE | MASK_UBE | MASK_SPP | MASK_FS 
                            | MASK_XS  | MASK_SUM  | MASK_MXR | MASK_UXL | MASK_SD;

// MIP / SIP field mask
pub const MASK_SSIP: u64 = 1 &lt;&lt; 1;
pub const MASK_MSIP: u64 = 1 &lt;&lt; 3;
pub const MASK_STIP: u64 = 1 &lt;&lt; 5;
pub const MASK_MTIP: u64 = 1 &lt;&lt; 7;
pub const MASK_SEIP: u64 = 1 &lt;&lt; 9;
pub const MASK_MEIP: u64 = 1 &lt;&lt; 11;
</code></pre>
<h3 id="3-csr-struct-and-api"><a class="header" href="#3-csr-struct-and-api">3. Csr struct and API</a></h3>
<p>We define a <code>Csr</code> struct to manage the CSRs. <code>Csr</code> also provides two major APIs: store and load. </p>
<p>我们定义一个 Csr 结构体来管理 CSR。Csr 同样提供两个主要的 API：load，store。</p>
<p class="filename">csr.rs</p>
<pre><code class="language-rs">const NUM_CSRS: usize = 4096;

pub struct Csr {
    csrs: [u64; NUM_CSRS],
}
impl Csr {
    pub fn new() -&gt; Csr {
        Self { csrs: [0; NUM_CSRS] }
    }

    pub fn load(&amp;self, addr: usize) -&gt; u64 {
        match addr {
            SIE =&gt; self.csrs[MIE] &amp; self.csrs[MIDELEG],
            SIP =&gt; self.csrs[MIP] &amp; self.csrs[MIDELEG],
            SSTATUS =&gt; self.csrs[MSTATUS] &amp; MASK_SSTATUS,
            _ =&gt; self.csrs[addr],
        }
    }

    pub fn store(&amp;mut self, addr: usize, value: u64) {
        match addr {
            SIE =&gt; self.csrs[MIE] = (self.csrs[MIE] &amp; !self.csrs[MIDELEG]) | (value &amp; self.csrs[MIDELEG]),
            SIP =&gt; self.csrs[MIP] = (self.csrs[MIE] &amp; !self.csrs[MIDELEG]) | (value &amp; self.csrs[MIDELEG]),
            SSTATUS =&gt; self.csrs[MSTATUS] = (self.csrs[MSTATUS] &amp; !MASK_SSTATUS) | (value &amp; MASK_SSTATUS),
            _ =&gt; self.csrs[addr] = value,
        }
    }
}
</code></pre>
<p>Register <code>mideleg</code> controls whether an interrupt is delegated to S-mode. If certain bit in mideleg is set, the corresponding field in <code>sie</code> become visible when a read or write operation is performed. The same rule applies to  <code>sip</code> and <code>sstatus</code>.</p>
<p>当我们读取<code>sie</code>时，我们读的是<code>mie</code>与<code>mideleg</code>相与的结果，当我们写<code>sie</code>时，我们同样只写<code>mideleg</code>中为<code>1</code>的位，其他的位保持不变。读写<code>sip</code>，<code>sstatus</code>与此类似。</p>
<p>We need to update the CPU 我们需要更新 CPU 的结构。</p>
<pre><code class="language-rs">pub struct Cpu {
    /// 32 64-bit integer registers.
    pub regs: [u64; 32],
    /// Program counter to hold the the dram address of the next instruction that would be executed.
    pub pc: u64,
    /// System bus that transfers data between CPU and peripheral devices.
    pub bus: Bus,
    /// Control and status registers. RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for
    /// up to 4096 CSRs.
    pub csr: Csr,
}

impl Cpu {
    /// Create a new `Cpu` object.
    pub fn new(code: Vec&lt;u8&gt;) -&gt; Self {
        let mut regs = [0; 32];
        regs[2] = DRAM_END;
        let pc = DRAM_BASE;
        let bus = Bus::new(code);
        let csr = Csr::new();

        Self {regs, pc, bus, csr}
    }
    // ...
}
</code></pre>
<h3 id="4-support-csrs-instructions"><a class="header" href="#4-support-csrs-instructions">4. support CSRs Instructions</a></h3>
<p>CSR instructions are described in the <code>Zicsr</code> chapter in RISC-V unprivileged ISA. There are six instructions totally defined.</p>
<p>CSR 指令在 RISC-V 非特权 ISA 中的第九章 <code>Zicsr</code> 中描述。CSR 的指令共有 6 个。</p>
<p><img src="./images/csr-inst.png" alt="csr-inst" /></p>
<p class="comment">Picture RISC-V unprivileged ISA: Zicsr</p>
<p>The <code>csr</code> field encodes the address of CSRs. (2^12 = 4096)。The description of each CSR instruction is as follow:</p>
<p>指令的<code>csr</code>字段有 12 位，编码的是寄存器的地址。(2^12 = 4096)。指令的含义如下：</p>
<p><img src="./images/csr-inst1.png" alt="csr-inst1" />
<img src="./images/csr-inst2.png" alt="csr-inst2" />
<img src="./images/csr-inst3.png" alt="csr-inst3" /></p>
<p class="comment">Picture from RISC-V Reader</p>
<p>You are encouraged to implement these instructions by yourself. When you complete, you can pass the following test.</p>
<p>可以自行实现，也可以复制项目中的源码。实现以上六个指令之后，可以进行下面的测试。</p>
<p class="filename">cpu.rs</p>
<pre><code class="language-rs">mod test {
    // ...
    #[test]
    fn test_csrs1() {
        let code = &quot;
            addi t0, zero, 1
            addi t1, zero, 2
            addi t2, zero, 3
            csrrw zero, mstatus, t0
            csrrs zero, mtvec, t1
            csrrw zero, mepc, t2
            csrrc t2, mepc, zero
            csrrwi zero, sstatus, 4
            csrrsi zero, stvec, 5
            csrrwi zero, sepc, 6
            csrrci zero, sepc, 0 
        &quot;;
        riscv_test!(code, &quot;test_csrs1&quot;, 20, &quot;mstatus&quot; =&gt; 1, &quot;mtvec&quot; =&gt; 2, &quot;mepc&quot; =&gt; 3,
                                            &quot;sstatus&quot; =&gt; 0, &quot;stvec&quot; =&gt; 5, &quot;sepc&quot; =&gt; 6);
    }
}
</code></pre>
<h3 id="5-conclusion"><a class="header" href="#5-conclusion">5. Conclusion</a></h3>
<p>This is a short chapter. We have added CSRs to our CPU and supported CSR instructions set. We have also imitated the restrict view of certain CSR register. On next chapter, we will support three RISC-V privilege levels and add more instructions.</p>
<p>这一章节较短，我们添加了对部分控制状态寄存器的读写支持，同时，我们模拟了部分寄存器。下一节，我们将添加 RISC-V 的特权等级，并支持相应的指令。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
